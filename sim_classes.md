# Simulator classes

There are 3: VisSim, VisCal, VisTrue. VisCal and VisTrue are derived from VisSim. The difference is the way that simulations are loaded, but they are all used in the same way, particularly by the Sampler.

Describing VisSim will cover how simulations are used, and what the data format is. 

## VisSim

A simulation contains observed visibilities, sky model visibilities, gains, and x offsets. They all can be found in the equation that relates them all:

V_obs<sub>ij</sub> = g<sub>i</sub>g<sub>j</sub>* V<sub>ij</sub>(1+x<sub>i</sub>+x<sub>j</sub>*)

Each of these - V\_obs, g, V, x - has it's own array inside a VisSim object (g is called g\_bar for average g, and V is called V\_model). For a single time and frequency, V\_obs and V are a 1-D array of complex values of length number\_of\_baselines. g and x are 1-D arrays of complex values of length number\_of\_antennas. However, there are multiple times and frequencies in the simulation, and V\_obs, V, g, and x values for all of them. This can be represented in a 3-D array where the first two indices are time and frequency. For V\_obs and V, the arrays are of size (number\_of\_times, number\_of\_frequencies, number\_of\_baselines); for g and x the arrays are of size (number\_of\_times, number\_of\_frequencies, number\_of\_antennas).

During sampling, these arrays are often flattened. That can be easily done in Python to produce a 1-D array in C order ([see ravel](https://numpy.org/doc/stable/reference/generated/numpy.ravel.html#numpy.ravel)). When sampling x values, a flat array is passed into the sampling equation, so that x values for all times/freqs/antennas are sampled in one step.

VisSim creates a simulation by creating random values (sensible values) for V, g, and x, and then calculating V\_obs. These values can then be used by accessing attributes or methods.

### Attributes

These are the attribute a user would typically access:

```
nant   	# Number of antennas
nvis	# Number of visibilities = number of baselines
ntime	# Number of times
nfreq	# Number of frequencies

# The data arrays
V_obs   # Observed visibilities
V_model	# V in the sampling equations and above
g_bar	# g
x		# gain offsets
```
There is an attribute "level" which should always be set to "approx" for the sampling. If it is set to "exact", then the sampling cannot be done because quadratic x terms will be included in the equation for V\_obs, which will become V#_obs<sub>ij</sub> = g<sub>i</sub>g<sub>j</sub>* V<sub>ij</sub>(1+x<sub>i</sub>+x<sub>j</sub>*+x<sub>i</sub>x<sub>j</sub>*). The exact calculation can be used for Bayesian/MCMC sampling.
### Methods

Some methods are typically only used by the sampling. Those that might be of use to the user are:

```
# Calculate V_obs from g, V, x. This may not be the same as the V_obs
# contained in the VisSim object if values have been altered.
get_simulated_visibilities(self, show_working=False)

# Calculate gg*(1+x+x*) for each baseline, i.e. what V would be multiplied by
def get_baseline_gains(self)

# Calculate g_bar(1+x) for every antenna. Since x are gain perturbations the
# actual gains assigned to each antenna need to be altered by those x values.
def get_antenna_gains(self)

# Calculate g_bar(1+x) for every antenna and replace g_bar by those values, and set 
# all the x values to 0.
def fold_x_into_gains(self):

# The unnormalized likelihood is a value from 0 to 1, and indicates how well the
# right hand side of the above equation equals the left hand side, for values inside
# the VisSim object. A value of 1 means they are equal. Only if unity_N=True, which
# assumes there is no noise on the data.
def get_unnormalized_likelihood(self, over_all=False, unity_N=False)
```

## VisCal

VisCal and VisTrue objects are only used for simulations of real HERA data generated by the non-redundant-pipeline. They can both be used in the same way as VisSim, but the simulation is loaded from files. The important thing is to understand what they mean.

VisCal does not contain the result of a simulation, but the result of calibration. It contains the result of running HERA redundant calibration on simulated visibilties V\_obs. It can also do absolute calibration if degeneracy\_fix=True when the object is created. These calibrations operate only on V\_obs, and produce g\_bar and V values. It does not produce x values (which are all 0 in the object).

The V\_obs values are generated by a simulation. The information about the simulation is in the VisTrue object.

The sampling always begins with the values in a VisCal object, which will be in vis\_redcal inside the Sampler object.

## VisTrue

To make a simulation, V values are generated from a simulated sky containing point sources and maybe diffuse emission. The simulation also generates antenna gains that are applied to the V values to produce V\_obs via the usual equation:

V_obs<sub>ij</sub> = g<sub>i</sub>g<sub>j</sub>* V<sub>ij</sub>

There are no x values (i.e. they are 0). However there is added noise, so the actual equation is 


V_obs<sub>ij</sub> = g<sub>i</sub>g<sub>j</sub>* V<sub>ij</sub> + n<sub>ij</sub>

These V\_obs values are the same as those in VisCal, but the g\_bar and V values are not the same. To summarize:

|VisCal      |VisTrue |Similarity |
| :----------- | :------------------: | :------------:|
| V\_obs      | V\_obs       | The same |
| g\_bar   | g\_bar        | Not the same |
| V   | V  | Not the same |

The calibration generates its own g\_bar and V, which can be compared to the g\_bar and V used to generate the simulation, which are the "true" values.

After running the sampling, there will be _another_ set of g\_bar and V (g\_bar can be generated by combining the x values from sampling into the gains g\_bar from redcal). These are in the vis\_sampled object which is in Sampler after sampling. Then we have:

|VisCal      |VisTrue | After sampling | Similarity |
| :----------- | :------------------: | :------------:| :---: |
| V\_obs      | V\_obs       | V\_obs | The same |
| g\_bar\_cal   | g\_bar\_true     | g\_bar\_samp| The same as VisCal |
| V\_cal   | V\_true  | V\_samp | Not the same |
This is rather confused because of the different object types. It needs to be cleaned up.






